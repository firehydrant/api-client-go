// Code generated by go-swagger; DO NOT EDIT.

package alerts

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new alerts API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for alerts API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CreateIncidentAlert(params *CreateIncidentAlertParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateIncidentAlertNoContent, error)

	DeleteIncidentAlert(params *DeleteIncidentAlertParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteIncidentAlertNoContent, error)

	GetAlert(params *GetAlertParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAlertOK, error)

	ListAlerts(params *ListAlertsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListAlertsOK, error)

	ListIncidentAlerts(params *ListIncidentAlertsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListIncidentAlertsOK, error)

	ListProcessingLogEntries(params *ListProcessingLogEntriesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProcessingLogEntriesOK, error)

	UpdateIncidentAlertPrimary(params *UpdateIncidentAlertPrimaryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIncidentAlertPrimaryOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
CreateIncidentAlert attaches an alert to an incident

Add an alert to an incident. FireHydrant needs to have ingested the alert from a third party system in order to attach it to the incident.
*/
func (a *Client) CreateIncidentAlert(params *CreateIncidentAlertParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateIncidentAlertNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateIncidentAlertParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "create_incident_alert",
		Method:             "POST",
		PathPattern:        "/v1/incidents/{incident_id}/alerts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateIncidentAlertReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateIncidentAlertNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for create_incident_alert: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteIncidentAlert removes an alert from an incident

Remove an alert from an incident
*/
func (a *Client) DeleteIncidentAlert(params *DeleteIncidentAlertParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteIncidentAlertNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteIncidentAlertParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "delete_incident_alert",
		Method:             "DELETE",
		PathPattern:        "/v1/incidents/{incident_id}/alerts/{incident_alert_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteIncidentAlertReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteIncidentAlertNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for delete_incident_alert: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetAlert gets an alert

Retrieve a single alert
*/
func (a *Client) GetAlert(params *GetAlertParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAlertOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAlertParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "get_alert",
		Method:             "GET",
		PathPattern:        "/v1/alerts/{alert_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAlertReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAlertOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for get_alert: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListAlerts lists alerts

Retrieve all alerts from third parties
*/
func (a *Client) ListAlerts(params *ListAlertsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListAlertsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListAlertsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "list_alerts",
		Method:             "GET",
		PathPattern:        "/v1/alerts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListAlertsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListAlertsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for list_alerts: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListIncidentAlerts lists alerts for an incident

List alerts that have been attached to an incident
*/
func (a *Client) ListIncidentAlerts(params *ListIncidentAlertsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListIncidentAlertsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListIncidentAlertsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "list_incident_alerts",
		Method:             "GET",
		PathPattern:        "/v1/incidents/{incident_id}/alerts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListIncidentAlertsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListIncidentAlertsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for list_incident_alerts: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListProcessingLogEntries lists alert processing log entries

Processing Log Entries for a specific alert
*/
func (a *Client) ListProcessingLogEntries(params *ListProcessingLogEntriesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProcessingLogEntriesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListProcessingLogEntriesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "list_processing_log_entries",
		Method:             "GET",
		PathPattern:        "/v1/processing_log_entries",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListProcessingLogEntriesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListProcessingLogEntriesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for list_processing_log_entries: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateIncidentAlertPrimary sets an alert as primary for an incident

Setting an alert as primary will overwrite milestone times in the FireHydrant incident with times included in the primary alert. Services attached to the primary alert will also be automatically added to the incident.
*/
func (a *Client) UpdateIncidentAlertPrimary(params *UpdateIncidentAlertPrimaryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIncidentAlertPrimaryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateIncidentAlertPrimaryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "update_incident_alert_primary",
		Method:             "PATCH",
		PathPattern:        "/v1/incidents/{incident_id}/alerts/{incident_alert_id}/primary",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateIncidentAlertPrimaryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateIncidentAlertPrimaryOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for update_incident_alert_primary: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
