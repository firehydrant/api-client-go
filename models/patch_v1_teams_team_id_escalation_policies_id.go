// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PatchV1TeamsTeamIDEscalationPoliciesID Update a Signals escalation policy by ID
//
// swagger:model patchV1TeamsTeamIdEscalationPoliciesId
type PatchV1TeamsTeamIDEscalationPoliciesID struct {

	// Whether this escalation policy should be the default for the team.
	Default *bool `json:"default,omitempty"`

	// A detailed description of the escalation policy.
	Description string `json:"description,omitempty"`

	// handoff step
	HandoffStep *PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStep `json:"handoff_step,omitempty"`

	// The escalation policy's name.
	Name string `json:"name,omitempty"`

	// The number of times that the escalation policy should repeat before an alert is dropped.
	Repetitions int32 `json:"repetitions,omitempty"`

	// A list of steps that define how an alert should escalate through the policy.
	Steps []*PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0 `json:"steps"`
}

// Validate validates this patch v1 teams team Id escalation policies Id
func (m *PatchV1TeamsTeamIDEscalationPoliciesID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHandoffStep(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSteps(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchV1TeamsTeamIDEscalationPoliciesID) validateHandoffStep(formats strfmt.Registry) error {
	if swag.IsZero(m.HandoffStep) { // not required
		return nil
	}

	if m.HandoffStep != nil {
		if err := m.HandoffStep.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("handoff_step")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("handoff_step")
			}
			return err
		}
	}

	return nil
}

func (m *PatchV1TeamsTeamIDEscalationPoliciesID) validateSteps(formats strfmt.Registry) error {
	if swag.IsZero(m.Steps) { // not required
		return nil
	}

	for i := 0; i < len(m.Steps); i++ {
		if swag.IsZero(m.Steps[i]) { // not required
			continue
		}

		if m.Steps[i] != nil {
			if err := m.Steps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("steps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("steps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch v1 teams team Id escalation policies Id based on the context it is used
func (m *PatchV1TeamsTeamIDEscalationPoliciesID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateHandoffStep(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSteps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchV1TeamsTeamIDEscalationPoliciesID) contextValidateHandoffStep(ctx context.Context, formats strfmt.Registry) error {

	if m.HandoffStep != nil {
		if err := m.HandoffStep.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("handoff_step")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("handoff_step")
			}
			return err
		}
	}

	return nil
}

func (m *PatchV1TeamsTeamIDEscalationPoliciesID) contextValidateSteps(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Steps); i++ {

		if m.Steps[i] != nil {
			if err := m.Steps[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("steps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("steps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchV1TeamsTeamIDEscalationPoliciesID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchV1TeamsTeamIDEscalationPoliciesID) UnmarshalBinary(b []byte) error {
	var res PatchV1TeamsTeamIDEscalationPoliciesID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStep A step that defines where an alert should be sent when the policy is exhausted and the alert is still unacknowledged.
//
// swagger:model PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStep
type PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStep struct {

	// The ID of the target to which the policy will hand off.
	// Required: true
	TargetID *string `json:"target_id"`

	// The type of target to which the policy will hand off.
	// Required: true
	// Enum: [EscalationPolicy Team]
	TargetType *string `json:"target_type"`
}

// Validate validates this patch v1 teams team ID escalation policies ID handoff step
func (m *PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStep) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTargetID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStep) validateTargetID(formats strfmt.Registry) error {

	if err := validate.Required("handoff_step"+"."+"target_id", "body", m.TargetID); err != nil {
		return err
	}

	return nil
}

var patchV1TeamsTeamIdEscalationPoliciesIdHandoffStepTypeTargetTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["EscalationPolicy","Team"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		patchV1TeamsTeamIdEscalationPoliciesIdHandoffStepTypeTargetTypePropEnum = append(patchV1TeamsTeamIdEscalationPoliciesIdHandoffStepTypeTargetTypePropEnum, v)
	}
}

const (

	// PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStepTargetTypeEscalationPolicy captures enum value "EscalationPolicy"
	PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStepTargetTypeEscalationPolicy string = "EscalationPolicy"

	// PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStepTargetTypeTeam captures enum value "Team"
	PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStepTargetTypeTeam string = "Team"
)

// prop value enum
func (m *PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStep) validateTargetTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, patchV1TeamsTeamIdEscalationPoliciesIdHandoffStepTypeTargetTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStep) validateTargetType(formats strfmt.Registry) error {

	if err := validate.Required("handoff_step"+"."+"target_type", "body", m.TargetType); err != nil {
		return err
	}

	// value enum
	if err := m.validateTargetTypeEnum("handoff_step"+"."+"target_type", "body", *m.TargetType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch v1 teams team ID escalation policies ID handoff step based on context it is used
func (m *PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStep) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStep) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStep) UnmarshalBinary(b []byte) error {
	var res PatchV1TeamsTeamIDEscalationPoliciesIDHandoffStep
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0 patch v1 teams team ID escalation policies ID steps items0
//
// swagger:model PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0
type PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0 struct {

	// The round robin configuration for the step. One of 'unspecified', 'round_robin_by_alert', or 'round_robin_by_escalation_policy'.
	// Enum: [unspecified round_robin_by_alert round_robin_by_escalation_policy]
	DistributionType string `json:"distribution_type,omitempty"`

	// A list of targets that the step will notify. You can specify up to 15 targets per step.
	Targets []*PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0 `json:"targets"`

	// An ISO8601 duration string specifying how long to wait before moving on to the next step. For the last step, this value specifies how long to wait before the escalation policy should repeat, if it repeats.
	// Required: true
	Timeout *string `json:"timeout"`
}

// Validate validates this patch v1 teams team ID escalation policies ID steps items0
func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDistributionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimeout(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var patchV1TeamsTeamIdEscalationPoliciesIdStepsItems0TypeDistributionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unspecified","round_robin_by_alert","round_robin_by_escalation_policy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		patchV1TeamsTeamIdEscalationPoliciesIdStepsItems0TypeDistributionTypePropEnum = append(patchV1TeamsTeamIdEscalationPoliciesIdStepsItems0TypeDistributionTypePropEnum, v)
	}
}

const (

	// PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0DistributionTypeUnspecified captures enum value "unspecified"
	PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0DistributionTypeUnspecified string = "unspecified"

	// PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0DistributionTypeRoundRobinByAlert captures enum value "round_robin_by_alert"
	PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0DistributionTypeRoundRobinByAlert string = "round_robin_by_alert"

	// PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0DistributionTypeRoundRobinByEscalationPolicy captures enum value "round_robin_by_escalation_policy"
	PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0DistributionTypeRoundRobinByEscalationPolicy string = "round_robin_by_escalation_policy"
)

// prop value enum
func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0) validateDistributionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, patchV1TeamsTeamIdEscalationPoliciesIdStepsItems0TypeDistributionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0) validateDistributionType(formats strfmt.Registry) error {
	if swag.IsZero(m.DistributionType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDistributionTypeEnum("distribution_type", "body", m.DistributionType); err != nil {
		return err
	}

	return nil
}

func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0) validateTargets(formats strfmt.Registry) error {
	if swag.IsZero(m.Targets) { // not required
		return nil
	}

	for i := 0; i < len(m.Targets); i++ {
		if swag.IsZero(m.Targets[i]) { // not required
			continue
		}

		if m.Targets[i] != nil {
			if err := m.Targets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("targets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("targets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0) validateTimeout(formats strfmt.Registry) error {

	if err := validate.Required("timeout", "body", m.Timeout); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this patch v1 teams team ID escalation policies ID steps items0 based on the context it is used
func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateTargets(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0) contextValidateTargets(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Targets); i++ {

		if m.Targets[i] != nil {
			if err := m.Targets[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("targets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("targets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0) UnmarshalBinary(b []byte) error {
	var res PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0 patch v1 teams team ID escalation policies ID steps items0 targets items0
//
// swagger:model PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0
type PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0 struct {

	// The ID of the target that the step will notify.
	// Required: true
	ID *string `json:"id"`

	// The type of target that the step will notify.
	// Required: true
	// Enum: [OnCallSchedule User SlackChannel EntireTeam Webhook]
	Type *string `json:"type"`
}

// Validate validates this patch v1 teams team ID escalation policies ID steps items0 targets items0
func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

var patchV1TeamsTeamIdEscalationPoliciesIdStepsItems0TargetsItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OnCallSchedule","User","SlackChannel","EntireTeam","Webhook"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		patchV1TeamsTeamIdEscalationPoliciesIdStepsItems0TargetsItems0TypeTypePropEnum = append(patchV1TeamsTeamIdEscalationPoliciesIdStepsItems0TargetsItems0TypeTypePropEnum, v)
	}
}

const (

	// PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0TypeOnCallSchedule captures enum value "OnCallSchedule"
	PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0TypeOnCallSchedule string = "OnCallSchedule"

	// PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0TypeUser captures enum value "User"
	PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0TypeUser string = "User"

	// PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0TypeSlackChannel captures enum value "SlackChannel"
	PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0TypeSlackChannel string = "SlackChannel"

	// PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0TypeEntireTeam captures enum value "EntireTeam"
	PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0TypeEntireTeam string = "EntireTeam"

	// PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0TypeWebhook captures enum value "Webhook"
	PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0TypeWebhook string = "Webhook"
)

// prop value enum
func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, patchV1TeamsTeamIdEscalationPoliciesIdStepsItems0TargetsItems0TypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch v1 teams team ID escalation policies ID steps items0 targets items0 based on context it is used
func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0) UnmarshalBinary(b []byte) error {
	var res PatchV1TeamsTeamIDEscalationPoliciesIDStepsItems0TargetsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
