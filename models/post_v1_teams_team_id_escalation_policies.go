// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PostV1TeamsTeamIDEscalationPolicies Create a Signals escalation policy for a team.
//
// swagger:model postV1TeamsTeamIdEscalationPolicies
type PostV1TeamsTeamIDEscalationPolicies struct {

	// Whether this escalation policy should be the default for the team.
	Default *bool `json:"default,omitempty"`

	// A detailed description of the escalation policy.
	Description string `json:"description,omitempty"`

	// handoff step
	HandoffStep *PostV1TeamsTeamIDEscalationPoliciesHandoffStep `json:"handoff_step,omitempty"`

	// The escalation policy's name.
	// Required: true
	Name *string `json:"name"`

	// The number of times that the escalation policy should repeat before an alert is dropped.
	Repetitions int32 `json:"repetitions,omitempty"`

	// A list of steps that define how an alert should escalate through the policy.
	// Required: true
	Steps []*PostV1TeamsTeamIDEscalationPoliciesStepsItems0 `json:"steps"`
}

// Validate validates this post v1 teams team Id escalation policies
func (m *PostV1TeamsTeamIDEscalationPolicies) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHandoffStep(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSteps(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PostV1TeamsTeamIDEscalationPolicies) validateHandoffStep(formats strfmt.Registry) error {
	if swag.IsZero(m.HandoffStep) { // not required
		return nil
	}

	if m.HandoffStep != nil {
		if err := m.HandoffStep.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("handoff_step")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("handoff_step")
			}
			return err
		}
	}

	return nil
}

func (m *PostV1TeamsTeamIDEscalationPolicies) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *PostV1TeamsTeamIDEscalationPolicies) validateSteps(formats strfmt.Registry) error {

	if err := validate.Required("steps", "body", m.Steps); err != nil {
		return err
	}

	for i := 0; i < len(m.Steps); i++ {
		if swag.IsZero(m.Steps[i]) { // not required
			continue
		}

		if m.Steps[i] != nil {
			if err := m.Steps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("steps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("steps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this post v1 teams team Id escalation policies based on the context it is used
func (m *PostV1TeamsTeamIDEscalationPolicies) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateHandoffStep(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSteps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PostV1TeamsTeamIDEscalationPolicies) contextValidateHandoffStep(ctx context.Context, formats strfmt.Registry) error {

	if m.HandoffStep != nil {
		if err := m.HandoffStep.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("handoff_step")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("handoff_step")
			}
			return err
		}
	}

	return nil
}

func (m *PostV1TeamsTeamIDEscalationPolicies) contextValidateSteps(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Steps); i++ {

		if m.Steps[i] != nil {
			if err := m.Steps[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("steps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("steps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PostV1TeamsTeamIDEscalationPolicies) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PostV1TeamsTeamIDEscalationPolicies) UnmarshalBinary(b []byte) error {
	var res PostV1TeamsTeamIDEscalationPolicies
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PostV1TeamsTeamIDEscalationPoliciesHandoffStep A step that defines where an alert should be sent when the policy is exhausted and the alert is still unacknowledged.
//
// swagger:model PostV1TeamsTeamIDEscalationPoliciesHandoffStep
type PostV1TeamsTeamIDEscalationPoliciesHandoffStep struct {

	// The ID of the target to which the policy will hand off.
	// Required: true
	TargetID *string `json:"target_id"`

	// The type of target to which the policy will hand off.
	// Required: true
	// Enum: [EscalationPolicy Team]
	TargetType *string `json:"target_type"`
}

// Validate validates this post v1 teams team ID escalation policies handoff step
func (m *PostV1TeamsTeamIDEscalationPoliciesHandoffStep) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTargetID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PostV1TeamsTeamIDEscalationPoliciesHandoffStep) validateTargetID(formats strfmt.Registry) error {

	if err := validate.Required("handoff_step"+"."+"target_id", "body", m.TargetID); err != nil {
		return err
	}

	return nil
}

var postV1TeamsTeamIdEscalationPoliciesHandoffStepTypeTargetTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["EscalationPolicy","Team"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		postV1TeamsTeamIdEscalationPoliciesHandoffStepTypeTargetTypePropEnum = append(postV1TeamsTeamIdEscalationPoliciesHandoffStepTypeTargetTypePropEnum, v)
	}
}

const (

	// PostV1TeamsTeamIDEscalationPoliciesHandoffStepTargetTypeEscalationPolicy captures enum value "EscalationPolicy"
	PostV1TeamsTeamIDEscalationPoliciesHandoffStepTargetTypeEscalationPolicy string = "EscalationPolicy"

	// PostV1TeamsTeamIDEscalationPoliciesHandoffStepTargetTypeTeam captures enum value "Team"
	PostV1TeamsTeamIDEscalationPoliciesHandoffStepTargetTypeTeam string = "Team"
)

// prop value enum
func (m *PostV1TeamsTeamIDEscalationPoliciesHandoffStep) validateTargetTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, postV1TeamsTeamIdEscalationPoliciesHandoffStepTypeTargetTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PostV1TeamsTeamIDEscalationPoliciesHandoffStep) validateTargetType(formats strfmt.Registry) error {

	if err := validate.Required("handoff_step"+"."+"target_type", "body", m.TargetType); err != nil {
		return err
	}

	// value enum
	if err := m.validateTargetTypeEnum("handoff_step"+"."+"target_type", "body", *m.TargetType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post v1 teams team ID escalation policies handoff step based on context it is used
func (m *PostV1TeamsTeamIDEscalationPoliciesHandoffStep) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PostV1TeamsTeamIDEscalationPoliciesHandoffStep) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PostV1TeamsTeamIDEscalationPoliciesHandoffStep) UnmarshalBinary(b []byte) error {
	var res PostV1TeamsTeamIDEscalationPoliciesHandoffStep
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PostV1TeamsTeamIDEscalationPoliciesStepsItems0 post v1 teams team ID escalation policies steps items0
//
// swagger:model PostV1TeamsTeamIDEscalationPoliciesStepsItems0
type PostV1TeamsTeamIDEscalationPoliciesStepsItems0 struct {

	// The round robin configuration for the step. One of 'unspecified', 'round_robin_by_alert', or 'round_robin_by_escalation_policy'.
	// Enum: [unspecified round_robin_by_alert round_robin_by_escalation_policy]
	DistributionType string `json:"distribution_type,omitempty"`

	// A list of targets that the step will notify. You can specify up to 15 targets per step.
	// Required: true
	Targets []*PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0 `json:"targets"`

	// An ISO8601 duration string specifying how long to wait before moving on to the next step. For the last step, this value specifies how long to wait before the escalation policy should repeat, if it repeats.
	// Required: true
	Timeout *string `json:"timeout"`
}

// Validate validates this post v1 teams team ID escalation policies steps items0
func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDistributionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimeout(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var postV1TeamsTeamIdEscalationPoliciesStepsItems0TypeDistributionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["unspecified","round_robin_by_alert","round_robin_by_escalation_policy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		postV1TeamsTeamIdEscalationPoliciesStepsItems0TypeDistributionTypePropEnum = append(postV1TeamsTeamIdEscalationPoliciesStepsItems0TypeDistributionTypePropEnum, v)
	}
}

const (

	// PostV1TeamsTeamIDEscalationPoliciesStepsItems0DistributionTypeUnspecified captures enum value "unspecified"
	PostV1TeamsTeamIDEscalationPoliciesStepsItems0DistributionTypeUnspecified string = "unspecified"

	// PostV1TeamsTeamIDEscalationPoliciesStepsItems0DistributionTypeRoundRobinByAlert captures enum value "round_robin_by_alert"
	PostV1TeamsTeamIDEscalationPoliciesStepsItems0DistributionTypeRoundRobinByAlert string = "round_robin_by_alert"

	// PostV1TeamsTeamIDEscalationPoliciesStepsItems0DistributionTypeRoundRobinByEscalationPolicy captures enum value "round_robin_by_escalation_policy"
	PostV1TeamsTeamIDEscalationPoliciesStepsItems0DistributionTypeRoundRobinByEscalationPolicy string = "round_robin_by_escalation_policy"
)

// prop value enum
func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0) validateDistributionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, postV1TeamsTeamIdEscalationPoliciesStepsItems0TypeDistributionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0) validateDistributionType(formats strfmt.Registry) error {
	if swag.IsZero(m.DistributionType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDistributionTypeEnum("distribution_type", "body", m.DistributionType); err != nil {
		return err
	}

	return nil
}

func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0) validateTargets(formats strfmt.Registry) error {

	if err := validate.Required("targets", "body", m.Targets); err != nil {
		return err
	}

	for i := 0; i < len(m.Targets); i++ {
		if swag.IsZero(m.Targets[i]) { // not required
			continue
		}

		if m.Targets[i] != nil {
			if err := m.Targets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("targets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("targets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0) validateTimeout(formats strfmt.Registry) error {

	if err := validate.Required("timeout", "body", m.Timeout); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this post v1 teams team ID escalation policies steps items0 based on the context it is used
func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateTargets(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0) contextValidateTargets(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Targets); i++ {

		if m.Targets[i] != nil {
			if err := m.Targets[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("targets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("targets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0) UnmarshalBinary(b []byte) error {
	var res PostV1TeamsTeamIDEscalationPoliciesStepsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0 post v1 teams team ID escalation policies steps items0 targets items0
//
// swagger:model PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0
type PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0 struct {

	// The ID of the target that the step will notify.
	// Required: true
	ID *string `json:"id"`

	// The type of target that the step will notify.
	// Required: true
	// Enum: [OnCallSchedule User SlackChannel EntireTeam Webhook]
	Type *string `json:"type"`
}

// Validate validates this post v1 teams team ID escalation policies steps items0 targets items0
func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

var postV1TeamsTeamIdEscalationPoliciesStepsItems0TargetsItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OnCallSchedule","User","SlackChannel","EntireTeam","Webhook"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		postV1TeamsTeamIdEscalationPoliciesStepsItems0TargetsItems0TypeTypePropEnum = append(postV1TeamsTeamIdEscalationPoliciesStepsItems0TargetsItems0TypeTypePropEnum, v)
	}
}

const (

	// PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0TypeOnCallSchedule captures enum value "OnCallSchedule"
	PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0TypeOnCallSchedule string = "OnCallSchedule"

	// PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0TypeUser captures enum value "User"
	PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0TypeUser string = "User"

	// PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0TypeSlackChannel captures enum value "SlackChannel"
	PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0TypeSlackChannel string = "SlackChannel"

	// PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0TypeEntireTeam captures enum value "EntireTeam"
	PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0TypeEntireTeam string = "EntireTeam"

	// PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0TypeWebhook captures enum value "Webhook"
	PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0TypeWebhook string = "Webhook"
)

// prop value enum
func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, postV1TeamsTeamIdEscalationPoliciesStepsItems0TargetsItems0TypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post v1 teams team ID escalation policies steps items0 targets items0 based on context it is used
func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0) UnmarshalBinary(b []byte) error {
	var res PostV1TeamsTeamIDEscalationPoliciesStepsItems0TargetsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
